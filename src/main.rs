/*
'Solstice' - this tool converts an InstAL parse (+ extra hint data) to an Ethereum
Solidity contract that is valid when run through solc, probably.

Author: Zachary Shannon
 */

extern crate serde;
extern crate serde_json;
extern crate regex;

use serde_json::Value;

use regex::Regex;
use regex::Captures;

use std::io::prelude::*;
use std::fs::File;
use std::path::Path;
use std::char;
use std::collections::HashMap;


/*
Load file at a file path to a string.
*/
fn file_to_string(path: String) -> String {
    let mut file = File::open(path).expect("Error opening file.");
    let mut contents = String::new();
    file.read_to_string(&mut contents).expect("Error reading file.");
    return contents;
}

/*
Load parse from json file.
 */
fn get_json_parse(path : String) -> Value {
    let mut contents = file_to_string(path);
    //Remove extra square brackets...
    contents.remove(0);
    contents.pop();
    let v : Value = serde_json::from_str(&contents).unwrap();
    return v;
}

/*
Convert instal types from json to rust vector.
 */
fn types_to_vec(parse : &Value) -> Vec<String> {
    //Trim curly braces
    let mut data : String = format!("{}", parse["contents"]["types"]);
    data.remove(0);
    data.pop();

    let mut vec : Vec<String> = Vec::new();

    //Split on commas
    let comma_split = data.split(",");
    for s in comma_split {
        //Split on colon
        let mut colon_split = s.split(":");
        let mut cur_name = String::from(colon_split.nth(0).unwrap());
        //Strip quote marks
        cur_name.remove(0);
        cur_name.pop();
        vec.push(cur_name);
    }

    return vec;
}

/*
Convert institution name to string.
*/
fn institution_name_to_string(parse : &Value) -> String {
    let mut data : String = format!("{}",
                                    parse["contents"]["names"]["institution"]);
    //Trim quote marks.
    data.remove(0);
    data.pop();
    return data;
}

/*
Maps types based on manual type set file.
First hashmap maps Instal -> Sol
Second hashmap maps Instal Init -> Literal val
This function is fragile.
Type set file isn't checked or anything. If its bad, you'll just get bad code
or an error.
 */
fn map_types(path : String) -> Vec<HashMap<String, String>> {
    let mut ret = Vec::new();
    let mut type_map : HashMap<String, String> = HashMap::new();
    let mut init_map : HashMap<String, String> = HashMap::new();
    let cont = file_to_string(path);

    //Split on newline
    let newline_split = cont.split("\n");
    for s in newline_split {
        //Fragile - these unwraps basically assume format is good.
        //Split on bang - first half tells us which map
        let mut bang_split = s.split("!");
        let map_type = String::from(bang_split.next().unwrap().trim());

        //Next half is the actual map - split on colon.
        //This is needed but not 100% sure why we get a None here and not earlier.
        //TODO Work this out.
        let mut mapping : String;
        let next_val = bang_split.next();
        match next_val {
            Some(st) => mapping = String::from(st),
            None => break,
        }

        let mut colon_split = mapping.split(":");

        //Store mapping.
        let inst_type = String::from(colon_split.next().unwrap().trim());
        let sol_type = String::from(colon_split.next().unwrap().trim());
        if map_type == "Type"{
            type_map.insert(inst_type, sol_type);
        }
        else {
            init_map.insert(inst_type, sol_type);
        }
    }
    ret.push(type_map);
    ret.push(init_map);
    return ret;
}

struct ContractElement {
    head : String,
    tail : String,
    is_block : bool,
    is_below : bool,
    unindent_after: bool,
}
//Probably should add an automatically generated id and check against that...
impl PartialEq for ContractElement {
    fn eq(&self, other: &ContractElement) -> bool {
        if self.tail == other.tail && self.head == other.head{
            return true;
        } else {
            return false;
        }
    }
}

/*
Generate the preamble using the institution name.
*/
fn generate_preamble(parse: &Value) -> ContractElement {
    let inst_name = institution_name_to_string(parse);
    //Escape { or } with another { or } in Rust.
    let begin : String = format!("//Code automatically generated by SOLSTICE\npragma solidity ^0.4.19;\ncontract {} {{", inst_name);
    let end : String = String::from("}");

    let preamble = ContractElement {
        head : begin,
        tail : end,
        is_block : true,
        is_below : false,
        unindent_after: false,
    };
    return preamble;
}

/*
Get names from blocks that are formatted like
{"create_contract":["User"],"transfer":["User","User"]}
*/
fn get_names_from_block(parse: &Value, block: &str) -> Vec<String> {
    let parse_str = format!("{}", parse["contents"][block]);
    let parse_str = parse_str.replace("{", "!");

    let mut names : Vec<String> = Vec::new();
    //let re = Regex::new("[,{{]\"(.*?)\":").unwrap();
    let re = Regex::new("(!|])(.*?)\":").unwrap();
    for cap in re.captures_iter(&parse_str) {
        let mut cur_cap = String::from(&cap[0]);
        names.push(cur_cap);
    }
    return trim_unwanted_chars(names);
}

//TODO Refactor...
fn trim_unwanted_chars(vec: Vec<String>) -> Vec<String> {
    let mut ret: Vec<String> = Vec::new();
    let unwanted = vec!["[", "]", "!", "\"", ",", ":"];
    for s in &vec {
        let mut new = s.clone();
        for c in &unwanted {
            new = new.replace(c, "");
        }
        new.trim();
        ret.push(new);
    }
    return ret;
}

/*
Requires you to pass the result of get_names_from_block.
Gets a map of types from block name.
Lets us deconstruct i.e. inst and ex events.
*/
fn get_types_from_block(parse: &Value, block: &str, names: &Vec<String>)
                        -> HashMap<String, Vec<String>> {
    let mut map : HashMap<String, Vec<String>> =  HashMap::new();

    for key in names {
        let mut i = 0;
        let mut val : Vec<String> = Vec::new();
        loop {
            let mut cur_val = format!("{}", parse["contents"][block][&key][i]);
            if cur_val == "null"{
                break;
            } else {
                cur_val.pop();
                cur_val.remove(0);
                cur_val.trim();
                val.push(cur_val);
            }
            i += 1;
        }
        map.insert(key.clone(), val);
    }
    return map;
}

fn string_to_code_line(s: String) -> ContractElement {
    let end : String = String::from("");

    let def = ContractElement {
        head : s,
        tail : end,
        is_block : false,
        is_below : false,
        unindent_after: false,
    };
    return def;
}

/*
TODO Refactor - this function is huge.
It works, but thats pretty much where any positives about it end.
*/
fn generate_global_elements(parse: &Value,
                            type_map: &HashMap<String, String>)
                            -> Vec<ContractElement> {
    let mut ret = Vec::new();

    //let inst_name = institution_name_to_string(parse);

    //Signature. Assumes just one thing in signature.
    //This is the type of the argument to the contract init function.
    //TODO Fix that.
    let mut create_contract : String
        = format!("{}", parse["contents"]["exevents"]["create_contract"]);
    create_contract.pop();
    create_contract.pop();
    create_contract.remove(0);
    create_contract.remove(0);
    create_contract.trim();

    //Create permission and power maps/representations.
    let ex_event_names : Vec<String> = get_names_from_block(parse, "exevents");
    let in_event_names : Vec<String> = get_names_from_block(parse, "inevents");

    let ex_events = get_types_from_block(parse, "exevents", &ex_event_names);
    let in_events = get_types_from_block(parse, "inevents", &in_event_names);

    //Initial Permissions and powers.
    //Problem - we need to keep track and then set when we declare.
    let mut initials : Vec<String> = Vec::new();

    let mut loop_it = 0;
    loop {
        let parse_initials = format!("{}", parse["contents"]["initials"][loop_it]);
        loop_it+=1;
        if parse_initials == "null"{
            break;
        } else {
            //Dissasemble output using regex. We want everything in quote marks...
            //TODO NO support for conditionals. Here is where it would go.
            let re = Regex::new("\"(.*?)\"").unwrap();
            let mut iter = re.captures_iter(&parse_initials);
            let cap : Captures = match iter.next() {
                Some(c) => c,
                None => panic!("Poorly formatted initial"),
            };
            //This is the type - either perm or pow.
            let init_type : String = String::from(cap.get(1).unwrap().as_str());
            let cap : Captures = match iter.next() {
                Some(c) => c,
                None => panic!("Poorly formatted initial"),
            };
            //This is the name of the event which we use.
            let event_name : String = String::from(cap.get(1).unwrap().as_str());

            //Generate vector entries.
            initials.push(format!("{}{}", event_name, init_type));
            }
    }

    //Explain what we're doing.
    ret.push(string_to_code_line(format!("//Permissions and empowerments.")));
    ret.push(string_to_code_line(format!("//Exogenous events.")));

    //For each name, get its associate types. Then for each type, create a boolean that
    //indicates either wildcard is on or a specific relationship.
    //Have one for both permission and power.
    for name in ex_event_names {
        let types = ex_events.get(&name).expect("Missing type map for exevent.");
        let mut pos = 0;
        for t in types {
            if initials.contains(&format!("{}perm", name)){
                ret.push(string_to_code_line(format!("bool {}_perm_wildcard_on_{} = true;", name, pos)));
            } else {
                ret.push(string_to_code_line(format!("bool {}_perm_wildcard_on_{} = false;", name, pos)));
            }

            if initials.contains(&format!("{}pow", name)){
                ret.push(string_to_code_line(format!("bool {}_pow_wildcard_on_{} = true;", name, pos)));
            } else {
                ret.push(string_to_code_line(format!("bool {}_pow_wildcard_on_{} = false;", name, pos)));
            }

            //Now do full lists.
            let map_from : String = match type_map.get(t) {
                Some(s) => s.clone(),
                None => panic!("No value for type {} in type map.", t),
            };

            ret.push(string_to_code_line(format!("mapping ({} => bool) private {}_perm_map_on_{};", map_from, name, pos)));
            ret.push(string_to_code_line(format!("mapping ({} => bool) private {}_pow_map_on_{};", map_from, name, pos)));
            pos += 1;
        }
    }

    //Insert an empty line.
    ret.push(string_to_code_line(format!("")));

    ret.push(string_to_code_line(format!("//Inst events.")));
    //Repeat for inevents.
    for name in in_event_names {
        let types = in_events.get(&name).expect("Missing type map for exevent.");
        let mut pos = 0;
        for t in types {
            if initials.contains(&format!("{}perm", name)){
                ret.push(string_to_code_line(format!("bool {}_perm_wildcard_on_{} = true;", name, pos)));
            } else {
                ret.push(string_to_code_line(format!("bool {}_perm_wildcard_on_{} = false;", name, pos)));
            }

            if initials.contains(&format!("{}pow", name)){
                ret.push(string_to_code_line(format!("bool {}_pow_wildcard_on_{} = true;", name, pos)));
            } else {
                ret.push(string_to_code_line(format!("bool {}_pow_wildcard_on_{} = false;", name, pos)));
            }

            //Now do full lists.
            let map_from : String = match type_map.get(t) {
                Some(s) => s.clone(),
                None => panic!("No value for type {} in type map.", t),
            };

            ret.push(string_to_code_line(format!("mapping ({} => bool) private {}_perm_map_on_{};", map_from, name, pos)));
            ret.push(string_to_code_line(format!("mapping ({} => bool) private {}_pow_map_on_{};", map_from, name, pos)));
            pos += 1;
        }
    }

    ret.push(string_to_code_line(format!("")));
    ret.push(string_to_code_line(format!("//Fluents")));

    let fluent_names : Vec<String> = get_names_from_block(parse, "fluents");
    let fluent_types : HashMap<String, Vec<String>> = get_types_from_block(parse,
                                                                           "fluents",
                                                                           &fluent_names);
    for name in fluent_names {
        let args = fluent_types.get(&name).expect("Fluent doesn't exist");
        for arg_idx in 0..args.len() {
            ret.push(string_to_code_line(format!("mapping(address => bool) public {}_{};",
                                                 name,
                                                 arg_idx)));
        }
    }
    ret.push(string_to_code_line(format!("")));

    return ret;
}

/*
Generate the contract creation function.
*/
fn generate_creation_fun(parse: &Value,
                         type_map: &HashMap<String, String>,
                         generates: &Vec<Vec<Vec<String>>>,
                         init_map: &HashMap<String, String>,
                         static_first: bool)
                         -> Vec<ContractElement> {
    let mut ret = Vec::new();

    let inst_name = institution_name_to_string(parse);

    //Signature. Assumes just one thing in signature.
    //This is the type of the argument to the contract init function.
    //TODO Fix that.
    let ex_event_names : Vec<String> = get_names_from_block(parse, "exevents");
    let ex_events = get_types_from_block(parse, "exevents", &ex_event_names);

    let mut begin : String = format!("function {}(", inst_name);

    //This char_num nonsense counts from a-z
    let mut char_num = 10;
    let types = ex_events.get("create_contract").expect("No create contract function");

    let first_arg_type = types.get(0).unwrap();
    for typ in types {
        if !static_first {
            begin += &format!("{} {}",
                              type_map.get(typ).expect("Error with type map"),
                              char::from_digit(char_num, 36).unwrap());
        }
        char_num += 1;
    }

    begin += ") public {";

    let end : String = String::from("}");

    let def = ContractElement {
        head : begin,
        tail : end,
        is_block : true,
        is_below : false,
        unindent_after: false,
    };
    ret.push(def);

    //Look for create_contract, see what it generates
    //(will generate inst_creation, presumably) and create appropriate fun calls.
    ret.push(string_to_code_line(format!("//Function calls for initial 'create_contract' event.")));

    //This block of code probably doesn't do anything particularly useful,
    //if we're honest with ourselves. In theory it should be extendable, though.
    for block in generates {
        if block[0][0] == "create_contract" {
            //Do matching.
            let mut head_block : Vec<String> = block[0].clone();
            head_block.remove(0);

            for i in 1..(block.len()-2) {
                let fun = block.get(i).expect("Array out of bounds");
                let mut fun_call : String = format!("{}(", fun.get(0).expect("No function name."));

                for j in 1..fun.len() {
                    //Check for a match.
                    //Copy previous letter assignment technique.
                    let arg = fun.get(j).expect("Malformed arg list");
                    let mut char_num = 10;
                    for head_arg in &head_block {
                        if arg == head_arg {
                            if char_num == 10 && static_first {
                                fun_call += &format!("{}", init_map.get(first_arg_type).unwrap());
                            } else {
                                fun_call += &format!("{}", char::from_digit(char_num, 36).unwrap());
                            }
                        }
                        char_num +=1;
                    }
                }
                fun_call += ");";
                ret.push(string_to_code_line(format!("{}", fun_call)));

            }

        }
    }

    return ret;
}

/*
Strips parse structure from a string - just grabs everything in quote marks and shoves it in a list.
*/
fn strip_parse_structure(s : String) -> Vec<String> {
    let mut ret : Vec<String> = Vec::new();

    let re = Regex::new("\"(.*?)\"").unwrap();
    let iter = re.captures_iter(&s);

    for cap in iter {
        let out_str : String = String::from(cap.get(1).unwrap().as_str());
        ret.push(out_str);
    }

    return ret;
}

fn fetch_relationship_from_parse(parse: &Value, relationship: &str) -> Vec<Vec<Vec<String>>> {
    let mut i = 0;
    let mut j = 0;

    let mut vecs : Vec<Vec<Vec<String>>> = Vec::new();

    loop {
        let mut loop_vec : Vec<Vec<String>> = Vec::new();
        let cur_parse = &parse["contents"][relationship][i];
        let check : String = format!("{}", cur_parse);

        if check == "null" {
            break;
        } else {
            loop {
                let cur_s : String = format!("{}", cur_parse[j]);
                if cur_s == "null" {
                    break;
                } else {
                    loop_vec.push(strip_parse_structure(cur_s));
                    j += 1;
                }
            }
            j = 0;
            i += 1;
            vecs.push(loop_vec);
        }
    }

    return vecs;
}

fn generate_function(type_map: &HashMap<String, String>,
                     init_map: &HashMap<String, String>,
                     function_name: String,
                     events: &HashMap<String, Vec<String>>,
                     generates: &Vec<Vec<Vec<String>>>,
                     initiates: &Vec<Vec<Vec<String>>>,
                     terminates: &Vec<Vec<Vec<String>>>,
                     public: bool,
                     static_first: bool,)
                     -> Vec<ContractElement> {

    let mut ret : Vec<ContractElement> = Vec::new();

    //For arguments - indexes all live in the same place, so this is how we keep track.
    //These 'arg types' can all be looked up in type map.
    let arg_types : Vec<String> = events.get(&function_name)
        .expect("Trying to generate function that doesn't exist.").clone();
    let mut my_args : Vec<String> = Vec::new();
    let num_args = arg_types.len();
    //Assign letters to each arg.
    let mut char_num = 10;
    for _ in 0..num_args {
        my_args.push(format!("{}", char::from_digit(char_num, 36).unwrap()));
        char_num += 1;
    }

    //Step 1 - Create function declaration block.
    //Types tbd.
    let mut begin : String = format!("function {}(", function_name);
    //Generate rest of begin statement for block:
    //This includes all argument definitions.
    //Skip the first arg if appropriate.
    let arg_start_idx = match (static_first && public) {
        true => 1,
        false => 0,
    };
    for i in arg_start_idx..my_args.len(){
        let cur_arg = my_args.get(i).unwrap();
        let cur_type = arg_types.get(i).unwrap();
        let cur_sol_type = type_map.get(cur_type).unwrap();
        if i == arg_types.len()-1 {
            begin += &format!("{} {}", cur_sol_type, cur_arg);
        }
        else {
            begin += &format!("{} {}, ", cur_sol_type, cur_arg);
        }
    }
    if public {
        begin += ") public {";
    } else {
        begin += ") private {";
    }

    let end : String = format!("}}");
    let def = ContractElement {
        head : begin,
        tail : end,
        is_block : true,
        is_below : true,
        unindent_after : false,
    };
    ret.push(def);

    //Handle static first.
    if static_first && public {
        let static_arg = my_args.get(0).unwrap();
        let static_type = arg_types.get(0).unwrap();
        let static_sol_type = type_map.get(static_type).unwrap();
        let static_init = init_map.get(static_type).unwrap();
        ret.push(string_to_code_line(format!("{} {} = {};",
                                             static_sol_type,
                                             static_arg,
                                             static_init)));
    }

    //Step 2 - Permissions and empowerment guards.
    ret.append(&mut generate_function_guards(function_name.clone(),
                                             num_args,
                                             &my_args,
                                             public));

    //Step 3 - Initiates
    //TODO Can you initiate a fluent and permissions in the same function? Probs no
    ret.append(&mut generate_function_initiates_terminates(function_name.clone(),
                                                            &my_args,
                                                            initiates,
                                                            false));
    //Step 4 - Generates
    ret.append(&mut generate_function_generates(function_name.clone(),
                                                &my_args,
                                                generates));
    //Step 5 - Terminates
    ret.append(&mut generate_function_initiates_terminates(function_name.clone(),
                                                           &my_args,
                                                           terminates,
                                                           true));

    return ret;
}

fn generate_function_guards(function_name: String,
                            num_args: usize,
                            my_args: &Vec<String>,
                            is_exo: bool)
                            -> Vec<ContractElement> {

    let mut ret: Vec<ContractElement> = Vec::new();
    let mut require : String = format!("require(");

    //Wildcards/maps
    for i in 0..num_args {
        let cur_arg = my_args.get(i).unwrap();
        if is_exo {
            require +=
                &format!("(({}_perm_wildcard_on_{} || {}_perm_map_on_{}[{}]) && ({}_pow_wildcard_on_{} || {}_pow_map_on_{}[{}])) && ",
                         function_name, i,
                         function_name, i, cur_arg,
                         function_name, i,
                         function_name, i, cur_arg);
        } else {
            require +=
                &format!("({}_perm_wildcard_on_{} || {}_perm_map_on_{}[{}]) && ",
                         function_name, i,
                         function_name, i, cur_arg);
        }
    }
    require.pop(); require.pop(); require.pop(); require.pop();
    require += ");";

    ret.push(string_to_code_line(require));
    return ret;
}

fn generate_function_generates(function_name: String,
                               function_args: &Vec<String>,
                               generates: &Vec<Vec<Vec<String>>>)
                               -> Vec<ContractElement> {
    let mut ret: Vec<ContractElement> = Vec::new();

    let mut lines_to_inspect: Vec<Vec<Vec<String>>> = Vec::new();
    for line in generates {
        let first_element = line.get(0).unwrap().get(0).unwrap();
        if first_element == &function_name {
            lines_to_inspect.push(line.clone());
        }
    }

    if lines_to_inspect.len() == 0 {
        //We're done.
        return ret;
    }

    let mut num_ifs = 0; //Needed to make nesting work properly...
    for line in lines_to_inspect {
        //Get args from the front of the statement.
        let mut args: Vec<String> = line.get(0).unwrap().clone();
        args.remove(0);

        //The conditional part of the statement.
        let mut conditional_args: Vec<String> = line.get(line.len()-2).unwrap().clone();
        let has_conditional: bool; //Needed for later.
        //Generate conditional block.
        if conditional_args.len() > 0 {
            has_conditional = true;

            let conditional: String;
            let negation: bool;
            if conditional_args.get(0).unwrap() == "not" {
                negation = true;
                conditional_args.remove(0);
                conditional = String::from(conditional_args
                                           .get(0).unwrap().clone());
                conditional_args.remove(0);
            } else {
                negation = false;
                conditional = String::from(conditional_args
                                           .get(0).unwrap().clone());
                conditional_args.remove(0);
            }
            //TODO Fix IF nesting,
            let mut start: String = format!("if(");
            for arg_idx in 0..conditional_args.len() {
                let arg = conditional_args.get(arg_idx).unwrap().clone();
                //Matching.
                let mut match_idx = 99;
                //Find corresponding index.
                for idx in 0..function_args.len() {
                    let comp = args.get(idx).unwrap();
                    if &arg == comp {
                        match_idx = idx;
                    }
                }
                //TODO Needs generalising and modifying if we want full fluent support.
                if match_idx < 99 {
                    if negation == true {
                        start += &format!("!{}_{}[{}] && ",
                                          conditional,
                                          arg_idx,
                                          function_args.get(match_idx).expect("??"));
                    } else {
                        start += &format!("{}_{}[{}] && ",
                                          conditional,
                                          arg_idx,
                                          function_args.get(match_idx).expect("??"));
                    }
                }
            }
            start.pop();start.pop();start.pop();start.pop();
            start += "){";
            let begin: String = start;
            let end: String = format!("}}");
            let mut def = ContractElement {
                head: begin,
                tail: end,
                is_block: true,
                is_below: match num_ifs {
                    0 => false,
                    _ => true,
                },
                unindent_after: true,
            };
            ret.push(def);
            num_ifs += 1;
        } else {
            has_conditional = false;
        }

        //Ignore first and last parts...
        //Then iterate through to generate fun calls.

       //Split what we're generating into individual words.

        let mut generates: Vec<Vec<String>> = Vec::new();
        let mut generates_cur: Vec<String> = Vec::new();

        for word_idx in 1..line.len()-1 {
            let cur = line.get(word_idx).unwrap().clone();
            for e in cur {
                if e.len() > 1 {
                    generates.push(generates_cur);
                    generates_cur = Vec::new();
                    generates_cur.push(e);
                } else {
                    generates_cur.push(e);
                }
            }
        }
        generates.push(generates_cur);

        //Pick indices...
        let limit: usize;
        if has_conditional {
            limit = generates.len()-1;
        } else {
            limit = generates.len();
        }
        for generates_idx in 1..limit {
            let mut generates_args = generates.get(generates_idx).unwrap().clone();


            //TODO Minor bug with code not generating certain
            //generates - i.e. if there are no ifs.
            //Below line is probably at fault...
            if generates_args.len() < 1 {
                continue;
            }

            let mut generates_call = generates_args.remove(0);
            if generates_call == "not" {
                continue; //Fixes an odd edge case.
            }

            let mut start: String = format!("{}(", generates_call);
            for arg in generates_args {
                //Matching
                let mut match_idx = 99;
                for idx in 0..function_args.len() {
                    let comp = args.get(idx).unwrap();
                    if &arg == comp {
                        match_idx = idx;
                    }
                }
                if match_idx < 99 {
                    start += &format!("{},", function_args.get(match_idx)
                                      .expect("??"));
                } else {
                    panic!("Scary wildcards in 'generates' statement from {}",
                           function_name);
                }
            }
            start.pop();
            start += ");";

            let begin: String = start;
            let end: String = format!("}}");
            let mut def = ContractElement {
                head : begin,
                tail : end,
                is_block : false,
                is_below : false,
                unindent_after: false,
            };
            ret.push(def);
        }
    }

    //Generate function calls.
    return ret;
}

/*
Generates the initiates and terminates calls inside a function.
TODO Solstice pattern matching needs rewriting as it does not support matching in body.
*/
fn generate_function_initiates_terminates(function_name: String,
                                          function_args: &Vec<String>,
                                          lines: &Vec<Vec<Vec<String>>>,
                                          terminates: bool)
                                          -> Vec<ContractElement> {

    let set_to: String = match terminates {
        true => String::from("false"),
        false => String::from("true"),
    };

    let mut ret: Vec<ContractElement> = Vec::new();

    //a statement like:
    //balance_up(U) lines has_money(U);
    //is a line consisting of words (e.g. balance_up(U)) consisting of elements
    //(e.g. balance_up, U)
    //That's how we iterates through the data structure.
    //The choice of data structure here is obv bad - so should refactor.
    for line_idx in 0..lines.len() {
        //Fetch line
        let line = lines.get(line_idx).unwrap();

        //Used for matching args in this line.
        let mut match_args : Vec<String> = Vec::new();

        //Look per word.
        for word_idx in 0..line.len() {
            let word = line.get(word_idx).unwrap();
            //The first word in a block determines if this function lines
            //the following words...
            if word_idx == 0 {
                if word.get(0).unwrap() == &function_name {
                    //'Match_args' are simply the args of the head.
                    match_args = word.clone();
                    match_args.remove(0); //Rmv function name.
                } else {
                    //Not relevant - ignore line
                    break;
                }
            } else {
                //Here is where we do the code generation.
                //We only ever reach this branch for a word IF
                //it is called by this function.
                //TODO Strip out conditionals.
                if word.len() == 0 {
                    //We need this because a bug somewhere means there is an empty
                    //element at the end of everything - this is scary for conditionals.
                    break;
                }

                let first_element = word.get(0).unwrap();

                if first_element == "perm" || first_element == "pow" {
                    //Need to go a level deeper -
                    //split the word down into things we can read.
                    let mut statements : Vec<Vec<String>> = Vec::new();
                    let mut cur_statement : Vec<String> = Vec::new();
                    for element in word {
                        if element == "perm" || element == "pow" {
                            if cur_statement.len() > 0 {
                                statements.push(cur_statement);
                            }
                            cur_statement = Vec::new();
                            cur_statement.push(element.clone());
                        }
                        else {
                            cur_statement.push(element.clone());
                        }
                    }
                    statements.push(cur_statement);

                    for statement in statements {
                        let mut element_args = statement.clone();
                        let type_of_change = element_args.remove(0);
                        let name_of_change = element_args.remove(0);

                        for arg_idx in 0..element_args.len() {
                            let cur_arg = element_args.get(arg_idx).unwrap();
                            //Index through the head args
                            let mut match_pos = 99;
                            for match_arg_idx in 0..match_args.len() {
                                let cur_match_arg = match_args
                                    .get(match_arg_idx)
                                    .unwrap();
                                if cur_arg == cur_match_arg {
                                    match_pos = match_arg_idx;
                                    break;
                                }
                            }
                            let mut out_line : String;
                            if match_pos == 99 {
                                //Must be wildcard.
                                out_line = format!("{}_{}_wildcard_on_{} = {};",
                                                   name_of_change,
                                                   type_of_change,
                                                   arg_idx,
                                                   set_to);
                            } else {
                                let matched_argument = function_args.get(match_pos)
                                    .expect("Initiates/terminates isn't callable!!!");
                                //Needs a mapping.
                                out_line = format!("{}_{}_map_on_{}[{}] = {};",
                                                   name_of_change,
                                                   type_of_change,
                                                   arg_idx,
                                                   matched_argument,
                                                   set_to);
                            }
                            ret.push(string_to_code_line(out_line));
                        }
                    }
                } else {
                    //This branch deals with 'lines'
                    let mut element_args = word.clone();
                    element_args.remove(0);
                    for arg_idx in 0..element_args.len() {
                        let cur_arg = element_args.get(arg_idx).unwrap();
                        //Index through the head args
                        let mut match_pos = 99;
                        for match_arg_idx in 0..match_args.len() {
                            let cur_match_arg = match_args.get(match_arg_idx).unwrap();
                            if cur_arg == cur_match_arg {
                                match_pos = match_arg_idx;
                                break;
                            }
                        }
                        let mut out_line : String = String::from("");
                        let matched_argument = function_args.get(match_pos)
                            .expect("Initiates/terminates isn't callable!!!");
                        for arg_idx in 0..element_args.len() {
                            out_line = format!("{}_{}[{}] = {};",
                                              first_element,
                                              arg_idx,
                                              matched_argument,
                                              set_to);
                        }
                        ret.push(string_to_code_line(out_line));
                    }
                }
            }
        }
    }
    return ret;
}

fn generate_functions(parse: &Value,
                      type_map: &HashMap<String, String>,
                      init_map: &HashMap<String, String>,
                      generates: &Vec<Vec<Vec<String>>>,
                      initiates: &Vec<Vec<Vec<String>>>,
                      terminates: &Vec<Vec<Vec<String>>>,
                      static_first: bool)
                      -> Vec<ContractElement> {

    let mut ret: Vec<ContractElement> = Vec::new();

    let ex_event_names: Vec<String> = get_names_from_block(parse, "exevents");
    let in_event_names: Vec<String> = get_names_from_block(parse, "inevents");

    let ex_events = get_types_from_block(parse, "exevents", &ex_event_names);
    let in_events = get_types_from_block(parse, "inevents", &in_event_names);

    for event in in_event_names {
        ret.append(&mut generate_function(type_map, init_map,
                                          event, &in_events,
                                          generates, initiates,
                                          terminates, false, static_first));
    }
    for event in ex_event_names {
        ret.append(&mut generate_function(type_map, init_map,
                                          event, &ex_events,
                                          generates,initiates,
                                          terminates, true, static_first));
    }

    return ret;
}

fn generate_violates(parse: &Value,
                     type_map: &HashMap<String, String>)
                     -> Vec<ContractElement> {
    let mut ret: Vec<ContractElement> = Vec::new();
    ret.push(string_to_code_line(String::from("//Violation events")));

    //probs loop here
    let violation_names : Vec<String> = get_names_from_block(parse, "vievents");
    let violation_events = get_types_from_block(parse, "vievents", &violation_names);

    for name in violation_names {
        let mut begin: String = format!("event {}(", name);

        let mut char_num = 10;
        let args = violation_events.get(&name).unwrap();
        for idx in 0..args.len() {
            let arg = args.get(idx).unwrap();
            let arg_type = type_map.get(arg).expect("Mismatch in type map - violates");
            begin += &format!("{} {}, ",
                              arg_type,
                              char::from_digit(char_num, 36).unwrap());
            char_num += 1;
        }
        begin.pop(); begin.pop();
        begin += ");";
        let end : String = format!("}}");
        let def = ContractElement {
            head : begin,
            tail : end,
            is_block : false,
            is_below : false,
            unindent_after : false,
        };
        ret.push(def);
        ret.push(string_to_code_line(String::from("")));
    }


    return ret;
}
/*
Generate final contract code.

Set 'static_first' to true if you wish to set the first argument using the init map, for exo
functions.

This is useful to make sure that the 'caller' of an exogenous event function is always
the literal caller in solidity, for example.
If this is not set, it will have to be done manually AFTER code generation.
*/
fn generate_contract_code(parse : &Value,
                          type_map_file_path : String,
                          static_first: bool)
                          -> Vec<ContractElement>{

    let mut contract = Vec::new();

    //Fetch generates/initiates
    let generates : Vec<Vec<Vec<String>>>
        = fetch_relationship_from_parse(parse, "generates");
    let initiates : Vec<Vec<Vec<String>>>
        = fetch_relationship_from_parse(parse, "initiates");
    let terminates : Vec<Vec<Vec<String>>>
        = fetch_relationship_from_parse(parse, "terminates");

    //Step 1 - Preamble.
    contract.push(generate_preamble(parse));

    //Step 2 - Types.
    let types : Vec<String> = types_to_vec(parse);
    let mut maps : Vec<HashMap<String, String>> = map_types(type_map_file_path);
    let init_map : HashMap<String, String> = maps.pop().unwrap();
    let type_map : HashMap<String, String> = maps.pop().unwrap();

    //Step 3 - Global
    contract.append(&mut generate_global_elements(parse, &type_map));

    //Step 4 - Violations
    contract.append(&mut generate_violates(parse, &type_map));

    //Step 5 - Contract Creation function.
    contract.append(&mut generate_creation_fun(parse, &type_map, &generates,
                                               &init_map, static_first));

    //Step 6 - Generate functions.
    contract.append(&mut generate_functions(parse, &type_map, &init_map,
                                            &generates, &initiates,
                                            &terminates, static_first));
    return contract;
}

/*
Converts list of contract elements to a string for output.
Includes correct indentation.
Simply by putting ContractElements in order and using the tail and block parts
correctly, this function will automatically indent and close your blocks.
*/
fn contract_to_string(contract : Vec<ContractElement>) -> String {
    let mut ret : String = String::new();
    let mut indents = 0;

    let empty_block = ContractElement {
        head : String::from(""),
        tail : String::from(""),
        is_block : true,
        is_below : false,
        unindent_after: false,
    };


    //List of blocks to ignore when we go back in reverse.
    let mut last_block_out: &ContractElement = &empty_block;
    let mut num_unindent_afters = 0;
    let mut last_block : &ContractElement = &empty_block;
    for i in 0..contract.len() {
        let mut e : &ContractElement = contract.get(i).expect("Array index oob");
        if e.is_block && e.is_below {
            //Close block above...
            indents -= 1;
            for _i in 0..indents {
                ret = ret + "  ";
            }
            if !e.unindent_after && num_unindent_afters > 0 {
                ret = ret + &last_block.tail + "\n";
                indents -= 1;
                for _i in 0..indents {
                    ret = ret + "  ";
                }
                ret = ret + &last_block_out.tail + "\n";
                num_unindent_afters = 0;
            } else if e.unindent_after {
                num_unindent_afters += 1;
                last_block = e;
                ret = ret + &last_block.tail + "\n";
            } else {
                ret = ret + &last_block.tail + "\n";
                last_block = e;
            }
            //Now write block below.
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &e.head + "\n";
            indents += 1;
        } else if e.is_block {
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &e.head + "\n";
            indents += 1;

            if e.unindent_after && num_unindent_afters == 0 {
                num_unindent_afters += 1;
                num_unindent_afters += 1;
                last_block_out = last_block;
                last_block = e;
            } else if e.unindent_after {
                num_unindent_afters += 1;
                last_block = e;
            } else {
                last_block = e;
            }
        } else {
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &e.head + "\n";
        }
    }
    for e in contract.iter().rev() {
        if e.is_block && e.is_below {
            //Skip closing blocks under these conditions -
            //they have already been closed.
            continue;
        } else if indents == 0 {
            //We've obviously gone too far.
            continue;
        }
        else if e.is_block {
            indents -= 1;
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &e.tail + "\n";
        } else {
            //Ignore tail on non-blocks.
        }
    }
    return ret;
}

/*
Jumping off point.
*/
fn main() {
    //Load parse data.
    let type_map_file_path = String::from("settype.typ");
    let json_file_path = String::from("parse.json");
    let parse = get_json_parse(json_file_path);

    let contract = generate_contract_code(&parse, type_map_file_path, true);
    let output = contract_to_string(contract);

    //https://rustbyexample.com/std_misc/file/create.html
    let out_path = Path::new("o.sol");
    let mut out_file : File = match File::create(&out_path) {
        Err(why) => panic!("Could not create out file: {}", why),
        Ok(out_file) => out_file,
    };
    match out_file.write_all(output.as_bytes()) {
        Err(why) => panic!("Couldn't write to out file: {}", why),
        Ok(_) => println!("Done."),
    }
}
