/*
'Solstice' - this tool converts an InstAL parse (+ extra hint data) to an Ethereum
Solidity contract that is valid when run through solc, probably.

Author: Zachary Shannon
 */

extern crate serde;
extern crate serde_json;
extern crate regex;

use serde_json::Value;

use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

use std::char;

use std::collections::HashMap;

use regex::Regex;
use regex::Captures;

/*
Load file at a file path to a string.
*/
fn file_to_string(path: String) -> String {
    let mut file = File::open(path).expect("Error opening file.");
    let mut contents = String::new();
    file.read_to_string(&mut contents).expect("Error reading file.");
    return contents;
}

/*
Load parse from json file.
 */
fn get_json_parse(path : String) -> Value {
    let mut contents = file_to_string(path);
    //Remove extra square brackets...
    contents.remove(0);
    contents.pop();
    let v : Value = serde_json::from_str(&contents).unwrap();
    return v;
}

/*
Convert instal types from json to rust vector.
 */
fn types_to_vec(parse : &Value) -> Vec<String> {
    //Trim curly braces
    let mut data : String = format!("{}", parse["contents"]["types"]);
    data.remove(0);
    data.pop();

    let mut vec : Vec<String> = Vec::new();

    //Split on commas
    let comma_split = data.split(",");
    for s in comma_split {
        //Split on colon
        let mut colon_split = s.split(":");
        let mut cur_name = String::from(colon_split.nth(0).unwrap());
        //Strip quote marks
        cur_name.remove(0);
        cur_name.pop();
        vec.push(cur_name);
    }

    return vec;
}

/*
Convert institution name to string.
*/
fn institution_name_to_string(parse : &Value) -> String {
    let mut data : String = format!("{}",
                                    parse["contents"]["names"]["institution"]);
    //Trim quote marks.
    data.remove(0);
    data.pop();
    return data;
}

/*
Maps types based on manual type set file.
First hashmap maps Instal -> Sol
Second hashmap maps Instal Init -> Literal val
This function is fragile.
Type set file isn't checked or anything. If its bad, you'll just get bad code
or an error.
 */
fn map_types(path : String) -> Vec<HashMap<String, String>> {
    let mut ret = Vec::new();
    let mut type_map : HashMap<String, String> = HashMap::new(); 
    let mut init_map : HashMap<String, String> = HashMap::new();
    let cont = file_to_string(path);

    //Split on newline
    let newline_split = cont.split("\n");
    for s in newline_split {
        //Fragile - these unwraps basically assume format is good.
        //Split on bang - first half tells us which map
        let mut bang_split = s.split("!");
        let map_type = String::from(bang_split.next().unwrap().trim());

        //Next half is the actual map - split on colon.
        //This is needed but not 100% sure why we get a None here and not earlier.
        //TODO Work this out.
        let mut mapping : String;
        let next_val = bang_split.next();
        match next_val {
            Some(st) => mapping = String::from(st),
            None => break,
        }

        let mut colon_split = mapping.split(":");

        //Store mapping.
        let inst_type = String::from(colon_split.next().unwrap().trim());
        let sol_type = String::from(colon_split.next().unwrap().trim());
        if map_type == "Type"{
            type_map.insert(inst_type, sol_type);
        }
        else {
            init_map.insert(inst_type, sol_type);
        }
    }
    ret.push(type_map);
    ret.push(init_map);
    return ret;
}

struct ContractElement {
    head : String,
    tail : String,
    is_block : bool,
    is_below : bool,
}
//Probably should add an automatically generated id and check against that...
impl PartialEq for ContractElement {
    fn eq(&self, other: &ContractElement) -> bool {
        if self.tail == other.tail && self.head == other.head{
            return true;
        } else {
            return false;
        }
    }
}

/*
Generate the preamble using the institution name.
*/
fn generate_preamble(parse: &Value) -> ContractElement {
    let inst_name = institution_name_to_string(parse);
    //Escape { or } with another { or } in Rust.
    let begin : String = format!("//Code automatically generated by SOLSTICE\npragma solidity ^0.4.19;\ncontract {} {{", inst_name);
    let end : String = String::from("}");

    let preamble = ContractElement {
        head : begin,
        tail : end,
        is_block : true,
        is_below : false,
    };
    return preamble;
}

/*
Get names from blocks that are formatted like
{"create_contract":["User"],"transfer":["User","User"]}
*/
fn get_names_from_block(parse: &Value, block: &str) -> Vec<String> {
    let parse_str = format!("{}", parse["contents"][block]);

    let mut names : Vec<String> = Vec::new();
    let re = Regex::new("[,{{]\"(.*?)\":").unwrap();
    for cap in re.captures_iter(&parse_str) {
        let mut cur_cap = String::from(&cap[0]);
        cur_cap.pop();
        cur_cap.pop();
        cur_cap.remove(0);
        cur_cap.remove(0);
        cur_cap.trim();
        names.push(cur_cap);
    }
    return names;
}

/*
Requires you to pass the result of get_names_from_block.
Gets a map of types from block name.
Lets us deconstruct i.e. inst and ex events.
*/
fn get_types_from_block(parse: &Value, block: &str, names: &Vec<String>) -> HashMap<String, Vec<String>> {
    let mut map : HashMap<String, Vec<String>> =  HashMap::new();

    for key in names {
        let mut i = 0;
        let mut val : Vec<String> = Vec::new();
        loop {
            let mut cur_val = format!("{}", parse["contents"][block][&key][i]);
            if cur_val == "null"{
                break;
            } else {
                cur_val.pop();
                cur_val.remove(0);
                cur_val.trim();
                val.push(cur_val);
            }
            i += 1;
        }
        map.insert(key.clone(), val);
    }
    return map;
}

fn string_to_code_line(s: String) -> ContractElement {
    let end : String = String::from("");

    let def = ContractElement {
        head : s,
        tail : end,
        is_block : false,
        is_below : false,
    };
    return def;
}

/*
TODO Refactor - this function is huge. It works, but thats pretty much where any positives about it end.
*/
fn generate_global_elements(parse: &Value, type_map: &HashMap<String, String>) -> Vec<ContractElement> {
    let mut ret = Vec::new();

    //let inst_name = institution_name_to_string(parse);

    //Signature. Assumes just one thing in signature.
    //This is the type of the argument to the contract init function.
    //TODO Fix that.
    let mut create_contract : String = format!("{}", parse["contents"]["exevents"]["create_contract"]);
    create_contract.pop();
    create_contract.pop();
    create_contract.remove(0);
    create_contract.remove(0);
    create_contract.trim();

    //Create permission and power maps/representations.
    let ex_event_names : Vec<String> = get_names_from_block(parse, "exevents");
    let in_event_names : Vec<String> = get_names_from_block(parse, "inevents");

    let ex_events = get_types_from_block(parse, "exevents", &ex_event_names);
    let in_events = get_types_from_block(parse, "inevents", &in_event_names);

    //Initial Permissions and powers.
    //Problem - we need to keep track and then set when we declare.
    let mut initials : Vec<String> = Vec::new();

    let mut loop_it = 0;
    loop {
        let parse_initials = format!("{}", parse["contents"]["initials"][loop_it]);
        loop_it+=1;
        if parse_initials == "null"{
            break;
        } else {
            //Dissasemble output using regex. We want everything in quote marks...
            //TODO NO support for conditionals. Here is where it would go.
            let re = Regex::new("\"(.*?)\"").unwrap();
            let mut iter = re.captures_iter(&parse_initials);
            let cap : Captures = match iter.next() {
                Some(c) => c,
                None => panic!("Poorly formatted initial"),
            };
            //This is the type - either perm or pow.
            let init_type : String = String::from(cap.get(1).unwrap().as_str());
            let cap : Captures = match iter.next() {
                Some(c) => c,
                None => panic!("Poorly formatted initial"),
            };
            //This is the name of the event which we use.
            let event_name : String = String::from(cap.get(1).unwrap().as_str());

            //Generate vector entries.
            initials.push(format!("{}{}", event_name, init_type));
            }
    }

    //Explain what we're doing.
    ret.push(string_to_code_line(format!("//Permissions and empowerments.")));
    ret.push(string_to_code_line(format!("//Exogenous events.")));

    //For each name, get its associate types. Then for each type, create a boolean that
    //indicates either wildcard is on or a specific relationship.
    //Have one for both permission and power.
    for name in ex_event_names {
        let types = ex_events.get(&name).expect("Missing type map for exevent.");
        let mut pos = 0;
        for t in types {
            if initials.contains(&format!("{}perm", name)){
                ret.push(string_to_code_line(format!("bool {}_perm_wildcard_on_{} = true;", name, pos)));
            } else {
                ret.push(string_to_code_line(format!("bool {}_perm_wildcard_on_{} = false;", name, pos)));
            }

            if initials.contains(&format!("{}pow", name)){
                ret.push(string_to_code_line(format!("bool {}_pow_wildcard_on_{} = true;", name, pos)));
            } else {
                ret.push(string_to_code_line(format!("bool {}_pow_wildcard_on_{} = false;", name, pos)));
            }

            //Now do full lists.
            let map_from : String = match type_map.get(t) {
                Some(s) => s.clone(),
                None => panic!("No value for type {} in type map.", t),
            };

            ret.push(string_to_code_line(format!("mapping ({} => bool) private {}_perm_map_on_{};", map_from, name, pos)));
            ret.push(string_to_code_line(format!("mapping ({} => bool) private {}_pow_map_on_{};", map_from, name, pos)));
            pos += 1;
        }
    }

    //Insert an empty line.
    ret.push(string_to_code_line(format!("")));

    ret.push(string_to_code_line(format!("//Inst events.")));
    //Repeat for inevents.
    for name in in_event_names {
        let types = in_events.get(&name).expect("Missing type map for exevent.");
        let mut pos = 0;
        for t in types {
            if initials.contains(&format!("{}perm", name)){
                ret.push(string_to_code_line(format!("bool {}_perm_wildcard_on_{} = true;", name, pos)));
            } else {
                ret.push(string_to_code_line(format!("bool {}_perm_wildcard_on_{} = false;", name, pos)));
            }

            if initials.contains(&format!("{}pow", name)){
                ret.push(string_to_code_line(format!("bool {}_pow_wildcard_on_{} = true;", name, pos)));
            } else {
                ret.push(string_to_code_line(format!("bool {}_pow_wildcard_on_{} = false;", name, pos)));
            }

            //Now do full lists.
            let map_from : String = match type_map.get(t) {
                Some(s) => s.clone(),
                None => panic!("No value for type {} in type map.", t),
            };

            ret.push(string_to_code_line(format!("mapping ({} => bool) private {}_perm_map_on_{};", map_from, name, pos)));
            ret.push(string_to_code_line(format!("mapping ({} => bool) private {}_pow_map_on_{};", map_from, name, pos)));
            pos += 1;
        }
    }

    ret.push(string_to_code_line(format!("")));
    ret.push(string_to_code_line(format!("//Fluents")));

    //TODO FULL FLUENT SUPPORT NOT IMPLEMENTED.
    let fluent_names : Vec<String> = get_names_from_block(parse, "fluents");
    //let fluents = get_types_from_block(parse, "fluents", &fluent_names);

    for name in fluent_names {
        ret.push(string_to_code_line(format!("mapping(address => bool) public {};", name)));
    }

    ret.push(string_to_code_line(format!("")));

    return ret;
}

/*
Generate the contract creation function.
*/
fn generate_creation_fun(parse: &Value, type_map : &HashMap<String, String>, generates : &Vec<Vec<Vec<String>>>) -> Vec<ContractElement> {
    let mut ret = Vec::new();

    let inst_name = institution_name_to_string(parse);

    //Signature. Assumes just one thing in signature.
    //This is the type of the argument to the contract init function.
    //TODO Fix that.
    let mut create_contract : String = format!("{}", parse["contents"]["exevents"]["create_contract"]);
    let ex_event_names : Vec<String> = get_names_from_block(parse, "exevents");
    let ex_events = get_types_from_block(parse, "exevents", &ex_event_names);

    create_contract.pop();
    create_contract.pop();
    create_contract.remove(0);
    create_contract.remove(0);
    create_contract.trim();

    let mut begin : String = format!("function {}(", inst_name);

    //This char_num nonsense counts from a-z
    let mut char_num = 10;
    for typ in ex_events.get("create_contract").expect("No create contract function") {
        begin += &format!("{} {}", type_map.get(typ).expect("Error with type map"), char::from_digit(char_num, 36).unwrap());
        char_num += 1;
    }

    begin += ") public {";

    let end : String = String::from("}");

    let def = ContractElement {
        head : begin,
        tail : end,
        is_block : true,
        is_below : false,
    };
    ret.push(def);

    //Look for create_contract, see what it generates
    //(will generate inst_creation, presumably) and create appropriate fun calls.
    ret.push(string_to_code_line(format!("//Function calls for initial 'create_contract' event.")));

    //This block of code probably doesn't do anything particularly useful,
    //if we're honest with ourselves. In theory it should be extendable, though.
    for block in generates {
        if block[0][0] == "create_contract" {
            //Do matching.
            let mut head_block : Vec<String> = block[0].clone();
            head_block.remove(0);

            for i in 1..(block.len()-2) {
                let fun = block.get(i).expect("Array out of bounds");
                let mut fun_call : String = format!("{}(", fun.get(0).expect("No function name."));

                for j in 1..fun.len() {
                    //Check for a match.
                    //Copy previous letter assignment technique.
                    let arg = fun.get(j).expect("Malformed arg list");
                    let mut char_num = 10;
                    for head_arg in &head_block {
                        if arg == head_arg {
                            fun_call += &format!("{}", char::from_digit(char_num, 36).unwrap());
                        }
                        char_num +=1;
                    }
                }
                fun_call += ");";
                ret.push(string_to_code_line(format!("{}", fun_call)));

            }

        }
    }

    return ret;
}

/*
Strips parse structure from a string - just grabs everything in quote marks and shoves it in a list.
*/
fn strip_parse_structure(s : String) -> Vec<String> {
    let mut ret : Vec<String> = Vec::new();

    let re = Regex::new("\"(.*?)\"").unwrap();
    let iter = re.captures_iter(&s);

    for cap in iter {
        let out_str : String = String::from(cap.get(1).unwrap().as_str());
        ret.push(out_str);
    }

    return ret;
}

fn fetch_relationship_from_parse(parse: &Value, relationship: &str) -> Vec<Vec<Vec<String>>> {
    let mut i = 0;
    let mut j = 0;

    let mut vecs : Vec<Vec<Vec<String>>> = Vec::new();

    loop {
        let mut loop_vec : Vec<Vec<String>> = Vec::new();
        let cur_parse = &parse["contents"][relationship][i];
        let check : String = format!("{}", cur_parse);
        //println!("Checkisat: {}", check);

        if check == "null" {
            break;
        } else {
            loop {
                let cur_s : String = format!("{}", cur_parse[j]);
                if cur_s == "null" {
                    //println!("Breaking loop");
                    break;
                } else {
                    //println!("sisat: {}", s);
                    loop_vec.push(strip_parse_structure(cur_s));
                    j += 1;
                }
            }
            j = 0;
            i += 1;
            vecs.push(loop_vec);
        }
    }

    return vecs;
}

fn generate_function(parse: &Value, type_map: &HashMap<String, String>, function_name: String, events: &HashMap<String, Vec<String>>, generates : &Vec<Vec<Vec<String>>>, initiates : &Vec<Vec<Vec<String>>>, public : bool) -> Vec<ContractElement> {
    let mut ret : Vec<ContractElement> = Vec::new();

    //For arguments - indexes all live in the same place, so this is how we keep track.
    //These 'arg types' can all be looked up in type map.
    let arg_types : Vec<String> = events.get(&function_name).expect("Trying to generate function that doesn't exist.").clone();
    let mut my_args : Vec<String> = Vec::new();
    let num_args = arg_types.len();
    //Assign letters to each arg.
    let mut char_num = 10;
    for _ in 0..num_args {
        my_args.push(format!("{}", char::from_digit(char_num, 36).unwrap()));
        char_num += 1;
    }

    //Step 1 - Create function declaration block.
    //Types tbd.
    let mut begin : String = format!("function {}(", function_name);
    //Generate rest of begin statement for block:
    //This includes all argument definitions.
    for i in 0..my_args.len(){
        let cur_arg = my_args.get(i).unwrap();
        let cur_type = arg_types.get(i).unwrap();
        let cur_sol_type = type_map.get(cur_type).unwrap();
        if i == arg_types.len()-1 {
            begin += &format!("{} {}", cur_sol_type, cur_arg);
        }
        else {
            begin += &format!("{} {}, ", cur_sol_type, cur_arg);
        }
    }
    if public {
        begin += ") public view {";
    } else {
        begin += ") private view {";
    }

    let end : String = format!("}}");
    let def = ContractElement {
        head : begin,
        tail : end,
        is_block : true,
        is_below : true,
    };
    ret.push(def);

    let mut require : String = format!("require((");
    //Step 2 - Permissions and empowerment guards.
    //TODO Ok I kind of ignore empowerements... They're not that important really.
    //of course that means it isn't semantically correct, but it probably isnt anyway.
    //Wildcards.
    for i in 0..num_args {
        if i == num_args-1 {
            require += &format!("{}_perm_wildcard_on_{} == true", function_name, i);
        } else {
            require += &format!("{}_perm_wildcard_on_{} == true && ", function_name, i);
        }
    }
    require += ") || (";
    for i in 0..num_args {
        let cur_arg = my_args.get(i).unwrap();
        if i == num_args-1 {
            require += &format!("{}_perm_map_on_{}[{}] == true", function_name, i, cur_arg);
        } else {
            require += &format!("{}_perm_map_on_{}[{}] == true && ", function_name, i, cur_arg);
        }
    }
    require += "));";
    ret.push(string_to_code_line(require));

    //Step 3 - Initiates
    //a statement like:
    //balance_up(U) initiates has_money(U);
    //is a line consisting of words (e.g. balance_up(U)) consisting of elements
    //(e.g. balance_up, U)
    //The choice of data structure here is obv bad, but I'm not changing it now.
    for line_idx in 0..initiates.len() {
        //Fetch line
        let line = initiates.get(line_idx).unwrap();

        //Used for matching args in this line.
        let mut match_args : Vec<String> = Vec::new();

        //Look per word.
        for word_idx in 0..line.len() {
            let word = line.get(word_idx).unwrap();
            //The first word in a block determines if this function initiates
            //the following words...
            if word_idx == 0 {
                if word.get(0).unwrap() == &function_name {
                    //'Match_args' are simply the args of the head.
                    match_args = word.clone();
                    match_args.remove(0); //Rmv function name.
                } else {
                    //Not relevant - ignore line
                    break;
                }
            } else {
                //Here is where we do the code generation.
                //We only ever reach this branch for a word IF
                //it is called by this function.
                //TODO Strip out conditionals.
                if word.len() == 0 {
                    //Not sure why we need this...
                    break;
                }

                let first_element = word.get(0).unwrap();

                if first_element == "perm" || first_element == "pow" {
                    //Need to go a level deeper -
                    //split the word down into things we can read.
                    let mut statements : Vec<Vec<String>> = Vec::new();
                    let mut cur_statement : Vec<String> = Vec::new();
                    for element in word {
                        println!("old: {}", element);
                        if element == "perm" || element == "pow" {
                            if cur_statement.len() > 0 {
                                statements.push(cur_statement);
                            }
                            cur_statement = Vec::new();
                            cur_statement.push(element.clone());
                        }
                        else {
                            cur_statement.push(element.clone());
                        }
                    }
                    statements.push(cur_statement);

                    for statement in statements {
                        let mut element_args = statement.clone();
                        let type_of_change = element_args.remove(0);
                        let name_of_change = element_args.remove(0);

                        for arg_idx in 0..element_args.len() {
                            let cur_arg = element_args.get(arg_idx).unwrap();
                            //Index through the head args
                            let mut match_pos = 99;
                            for match_arg_idx in 0..match_args.len() {
                                let cur_match_arg = match_args
                                    .get(match_arg_idx)
                                    .unwrap();
                                if cur_arg == cur_match_arg {
                                    match_pos = match_arg_idx;
                                    break;
                                }
                            }
                            let mut out_line : String;
                            if match_pos == 99 {
                                //Must be wildcard.
                                out_line = format!("{}_{}_wildcard_on_{} = true;",
                                                   name_of_change,
                                                   type_of_change,
                                                   arg_idx);
                            } else {
                                let matched_argument = my_args.get(match_pos)
                                    .expect("Initiates isn't callable!!!");
                                //Needs a mapping.
                                out_line = format!("{}_{}_on_{}[{}] = true;",
                                                   name_of_change,
                                                   type_of_change,
                                                   arg_idx,
                                                   matched_argument);
                            }
                            ret.push(string_to_code_line(out_line));
                        }
                    }
                } else {
                    //This branch deals with 'initiates'
                    let mut element_args = word.clone();
                    element_args.remove(0);
                    for arg_idx in 0..element_args.len() {
                        let cur_arg = element_args.get(arg_idx).unwrap();
                        //Index through the head args
                        let mut match_pos = 99;
                        for match_arg_idx in 0..match_args.len() {
                            let cur_match_arg = match_args.get(match_arg_idx).unwrap();
                            if cur_arg == cur_match_arg {
                                match_pos = match_arg_idx;
                                break;
                            }
                        }
                        let mut out_line : String;
                        let matched_argument = my_args.get(match_pos)
                            .expect("Initiates isn't callable!!!");
                        out_line = format!("{}[{}] = true;",
                                           first_element,
                                           matched_argument);
                        ret.push(string_to_code_line(out_line));
                    }
                }
            }
        }
    }
    ret.push(string_to_code_line(format!("")));

    //Step 4 - Generates
    //Step 5 - Terminates

    return ret;
}

fn generate_functions(parse: &Value, type_map : &HashMap<String, String>, generates : &Vec<Vec<Vec<String>>>, initiates : &Vec<Vec<Vec<String>>>) -> Vec<ContractElement> {
    let mut ret : Vec<ContractElement> = Vec::new();

    let ex_event_names : Vec<String> = get_names_from_block(parse, "exevents");
    let in_event_names : Vec<String> = get_names_from_block(parse, "inevents");

    let ex_events = get_types_from_block(parse, "exevents", &ex_event_names);
    let in_events = get_types_from_block(parse, "inevents", &in_event_names);

    for event in in_event_names {
        ret.append(&mut generate_function(parse, type_map, event, &in_events, generates,initiates, false));
        ret.push(string_to_code_line(String::from("")));
    }
    for event in ex_event_names {
        ret.append(&mut generate_function(parse, type_map, event, &ex_events, generates,initiates, true));
        ret.push(string_to_code_line(String::from("")));
    }

    return ret;
}
/*
Generate final contract code.
*/
fn generate_contract_code(parse : &Value,
                          type_map_file_path : String) -> Vec<ContractElement>{

    let mut contract = Vec::new();

    //Fetch generates/initiates
    let generates : Vec<Vec<Vec<String>>> = fetch_relationship_from_parse(parse, "generates");
    let mut initiates : Vec<Vec<Vec<String>>> = fetch_relationship_from_parse(parse, "initiates");

    //Step 1 - Preamble.
    contract.push(generate_preamble(parse));

    //Step 2 - Types.
    let types : Vec<String> = types_to_vec(parse);
    let mut maps : Vec<HashMap<String, String>> = map_types(type_map_file_path);
    let init_map : HashMap<String, String> = maps.pop().unwrap();
    let type_map : HashMap<String, String> = maps.pop().unwrap();

    println!("Type mappings are as follows:");
    for t in types{
        //Error handling if there is no match.
        match type_map.get(&t) {
            Some(st) => println!("{} -> {}", t, st),
            None => panic!("No match for type {} in map file.", t)
        }
    }
    println!("End type mappings.\n");

    //Step 3 - Global
    contract.append(&mut generate_global_elements(parse, &type_map));

    //Step 4 - Contract Creation function.
    contract.append(&mut generate_creation_fun(parse, &type_map, &generates));

    //Out one level.

    //Step 5 - Generate functions.
    contract.append(&mut generate_functions(parse, &type_map, &generates, &initiates));
    return contract;
}

/*
Converts list of contract elements to a string for output.
Includes correct indentation.
Simply by putting ContractElements in order and using the tail and block parts
correctly, this function will automatically indent and close your blocks.
*/
fn contract_to_string(contract : Vec<ContractElement>) -> String {
    let mut ret : String = String::new();
    let mut indents = 0;

    let empty_block = ContractElement {
        head : String::from(""),
        tail : String::from(""),
        is_block : true,
        is_below : false,
    };


    //List of blocks to ignore when we go back in reverse.
    let mut ignore_list : Vec<&ContractElement> = Vec::new();
    let mut last_block : &ContractElement = &empty_block;
    for i in 0..contract.len() {
        let mut e : &ContractElement = contract.get(i).expect("Array index oob");
        if e.is_block && e.is_below {
            //Close block above...
            indents -= 1;
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &last_block.tail + "\n";
            //We don't want to revisit this block ever again.
            ignore_list.push(last_block);
            //Now write block below.
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &e.head + "\n";
            indents += 1;
        } else if e.is_block {
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &e.head + "\n";
            indents += 1;
            last_block = e;
        } else {
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &e.head + "\n";
        }
    }
    for e in contract.iter().rev() {
        if e.is_block {
            if ignore_list.contains(&e){
                continue;
            }
            indents -= 1;
            for _i in 0..indents {
                ret = ret + "  ";
            }
            ret = ret + &e.tail + "\n";
        } else {
            //Ignore tail on non-blocks.
        }
    }
    return ret;
}

/*
Jumping off point.
*/
fn main() {
    //Load parse data.
    let type_map_file_path = String::from("settype.typ");
    let json_file_path = String::from("parse.json");
    let parse = get_json_parse(json_file_path);

    let contract = generate_contract_code(&parse, type_map_file_path);
    let output = contract_to_string(contract);

    //https://rustbyexample.com/std_misc/file/create.html
    let out_path = Path::new("o.sol");
    let mut out_file : File = match File::create(&out_path) {
        Err(why) => panic!("Could not create out file: {}", why),
        Ok(out_file) => out_file,
    };
    match out_file.write_all(output.as_bytes()) {
        Err(why) => panic!("Couldn't write to out file: {}", why),
        Ok(_) => println!("Done."),
    }
}
